<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>حل تمرینات جدید</title>
    <!-- Importing Vazirmatn font for Persian text -->
    <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* General body styling */
        body {
            font-family: 'Vazirmatn', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.8;
            margin: 20px;
            background-color: #f4f4f4;
            color: #333;
            direction: rtl; /* Set text direction to right-to-left for Persian */
            text-align: right; /* Align text to the right */
        }
        /* Container for main content */
        .container {
            max-width: 800px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        /* Styling for headings */
        h1, h2, h3, h4 {
            color: #0056b3;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        /* Styling for lists */
        ol, ul {
            padding-right: 20px; /* Adjust padding for RTL */
        }
        ol {
            list-style-type: decimal;
        }
        li {
            margin-bottom: 8px;
        }
        /* Styles for the text-based diagram */
        pre {
            background-color: #f8f8f8;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            text-align: left; /* Keep code/diagram text alignment left for readability */
            direction: ltr; /* Force left-to-right for the diagram for correct rendering */
            font-family: 'Consolas', 'Monaco', 'Lucida Console', monospace;
            white-space: pre-wrap; /* Ensure text wraps */
        }
    </style>
    <!-- MathJax for rendering LaTeX formulas -->
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script>
      // Configure MathJax to process LaTeX delimited by $...$ and $$...$$
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
</head>
<body>
    <div class="container">
        <h1>حل تمرینات جدید</h1>
        <p>
            در ادامه، حل تمرینات جدید مربوط به مدل نرون و معماری شبکه عصبی آورده شده است.
        </p>

        <h2>تمرین E.2.1</h2>
        <h3>صورت سوال:</h3>
        <p>
            ورودی یک نرون تک ورودی برابر $2.0$، وزن آن $1.3$ و بایاس آن $3.0$ است.
            این نرون در صورتی که خروجی آن به شرح زیر باشد، چه نوع توابع انتقالی می‌تواند داشته باشد (بر اساس جدول ۲.۱):
        </p>
        <ol type="i">
            <li>$1.6$</li>
            <li>$1.0$</li>
            <li>$0.9963$</li>
            <li>$-1.0$</li>
        </ol>

        <h3>پاسخ:</h3>
        <p>
            ابتدا، ورودی خالص (net input) نرون را محاسبه می‌کنیم:
            وزن ($W$) = $1.3$
            ورودی ($p$) = $2.0$
            بایاس ($b$) = $3.0$
        </p>
        $$
        n = Wp + b = (1.3)(2.0) + 3.0 = 2.6 + 3.0 = 5.6
        $$
        <p>
            حالا به بررسی هر حالت برای خروجی می‌پردازیم:
        </p>
        <ol type="i">
            <li>
                **خروجی $1.6$:**
                <p>با توجه به ورودی خالص $n = 5.6$، تنها یک تابع انتقال <b>خطی (purelin)</b> می‌تواند خروجی $1.6$ را تولید کند، در صورتی که ورودی خالص آن $1.6$ باشد. اما از آنجایی که ورودی خالص محاسبه شده ما $5.6$ است، هیچ یک از توابع انتقال استاندارد (مانند خطی، لگاریتمی-سیگموئید، تانژانت-سیگموئید، یا حد سخت) نمی‌توانند با ورودی خالص $5.6$، خروجی دقیقاً $1.6$ را تولید کنند. اگر سوال به این معنی باشد که آیا تابع خطی می‌تواند خروجی $1.6$ تولید کند، پاسخ بله است، اما در آن صورت ورودی خالص باید $1.6$ باشد نه $5.6$.</p>
            </li>
            <li>
                **خروجی $1.0$:**
                <p>توابع انتقالی که می‌توانند خروجی $1.0$ را برای ورودی خالص $n=5.6$ تولید کنند عبارتند از:</p>
                <ul>
                    <li><b>Hard Limit (hardlim):</b> از آنجایی که $5.6 \ge 0$ است، خروجی $1$ خواهد بود.</li>
                    <li><b>Symmetric Hard Limit (hardlims):</b> از آنجایی که $5.6 \ge 0$ است، خروجی $1$ خواهد بود.</li>
                    <li><b>Log-sigmoid (logsig):</b> برای ورودی‌های مثبت بزرگ، خروجی به $1$ نزدیک می‌شود. $logsig(5.6) \approx 0.9963$.</li>
                    <li><b>Tan-sigmoid (tansig):</b> برای ورودی‌های مثبت بزرگ، خروجی به $1$ نزدیک می‌شود. $tansig(5.6) \approx 0.9999$.</li>
                </ul>
            </li>
            <li>
                **خروجی $0.9963$:**
                <p><b>Log-sigmoid (logsig)</b> بهترین گزینه است. برای $n = 5.6$، خروجی $logsig(5.6) = \frac{1}{1 + e^{-5.6}} \approx 0.9963$.</p>
            </li>
            <li>
                **خروجی $-1.0$:**
                <p>توابع انتقالی که می‌توانند خروجی $-1.0$ را تولید کنند عبارتند از <b>Symmetric Hard Limit (hardlims)</b> و <b>Tan-sigmoid (tansig)</b>. با این حال، برای ورودی خالص $n=5.6$، خروجی هر دو تابع $+1$ خواهد بود. برای تولید خروجی $-1$، ورودی خالص باید منفی باشد (برای hardlims) یا بسیار منفی باشد (برای tansig).</p>
            </li>
        </ol>

        <h2>تمرین E.2.2</h2>
        <h3>صورت سوال:</h3>
        <p>
            یک نرون تک ورودی با بایاس را در نظر بگیرید. می‌خواهیم خروجی برای ورودی‌های کمتر از $3$ برابر $-1$ و برای ورودی‌های بزرگتر یا مساوی $3$ برابر $+1$ باشد.
        </p>
        <ol type="i">
            <li>چه نوع تابع انتقالی مورد نیاز است؟</li>
            <li>چه بایاسی را پیشنهاد می‌کنید؟ آیا بایاس شما به وزن ورودی مرتبط است؟ اگر بله، چگونه؟</li>
            <li>شبکه خود را با نام تابع انتقال، وزن و بایاس خلاصه کنید. یک دیاگرام از شبکه بکشید.</li>
        </ol>

        <h3>پاسخ:</h3>
        <p>
            هدف ما این است که خروجی نرون یک آستانه در ورودی $p=3$ داشته باشد: $-1$ برای $p < 3$ و $+1$ برای $p \ge 3$.
        </p>
        <ol type="i">
            <li>
                **چه نوع تابع انتقالی مورد نیاز است؟**
                <p>این رفتار دقیقاً همانند یک <b>تابع انتقال Hard Limit متقارن (symmetric hard limit یا hardlims)</b> است. این تابع به گونه‌ای عمل می‌کند که اگر ورودی خالص (net input) مثبت باشد خروجی $+1$ و اگر منفی باشد خروجی $-1$ خواهد بود.</p>
            </li>
            <li>
                **چه بایاسی را پیشنهاد می‌کنید؟ آیا بایاس شما به وزن ورودی مرتبط است؟ اگر بله، چگونه؟**
                <p>فرض می‌کنیم وزن ورودی ($W$) برابر $1$ است (در صورتی که در سوال مشخص نشده باشد، معمولاً $1$ در نظر گرفته می‌شود). ورودی خالص ($n$) به صورت $n = Wp + b$ محاسبه می‌شود. ما می‌خواهیم نقطه آستانه در $p=3$ باشد، یعنی زمانی که $p=3$، ورودی خالص $n$ برابر $0$ شود:</p>
                $$
                n = Wp + b = (1)(3) + b = 0 \implies 3 + b = 0 \implies b = -3
                $$
                <p>پس، بایاس پیشنهادی $b = -3$ است.</p>
                <p>بله، بایاس به وزن ورودی مرتبط است. رابطه به این صورت است که $b = -W \times \text{آستانه مورد نظر}$. در اینجا، $b = -1 \times 3 = -3$.</p>
            </li>
            <li>
                **شبکه خود را با نام تابع انتقال، وزن و بایاس خلاصه کنید. یک دیاگرام از شبکه بکشید.**
                <ul>
                    <li>**نوع نرون:** نرون با تابع انتقال Symmetric Hard Limit (<code>hardlims</code>)</li>
                    <li>**تعداد ورودی‌ها:** 1</li>
                    <li>**وزن ($W$):** $W = [1]$</li>
                    <li>**بایاس ($b$):** $b = [-3]$</li>
                    <li>**خروجی ($a$):** $a = \text{hardlims}(p - 3)$</li>
                </ul>
                <h4>دیاگرام شبکه:</h4>
                <pre><code>
     p --(W=1)--\
                 |---(+)--- (n = p - 3) ---[hardlims]--- a
                      ^
                      |
                    (b=-3)
                </code></pre>
                <p>(این یک نمایش متنی ساده از دیاگرام است. $p$ به عنوان ورودی، یک خط به سمت جمع‌کننده با وزن $W$ کشیده می‌شود، بایاس $b$ به جمع‌کننده اضافه می‌شود، و نتیجه از طریق یک بلوک "hardlims" به خروجی $a$ می‌رسد.)</p>
            </li>
        </ol>

        <h2>تمرین E.2.3</h2>
        <h3>صورت سوال:</h3>
        <p>
            یک نرون دو ورودی با ماتریس وزن $W=\begin{bmatrix}3 & 2\end{bmatrix}$ و بردار ورودی $p=\begin{bmatrix}-5 \\ 7\end{bmatrix}$ داده شده است. می‌خواهیم خروجی $0.5$ داشته باشیم. آیا ترکیبی از بایاس و تابع انتقال می‌تواند این امر را ممکن کند؟
        </p>
        <ol type="i">
            <li>آیا تابع انتقالی از جدول ۲.۱ وجود دارد که اگر بایاس صفر باشد، این کار را انجام دهد؟</li>
            <li>آیا بایاسی وجود دارد که اگر از تابع انتقال خطی استفاده شود، این کار را انجام دهد؟ اگر بله، چیست؟</li>
            <li>آیا بایاسی وجود دارد که اگر از تابع انتقال log-sigmoid استفاده شود، این کار را انجام دهد؟ اگر بله، چیست؟</li>
        </ol>

        <h3>پاسخ:</h3>
        <p>
            ابتدا ورودی خالص (net input) نرون را بدون در نظر گرفتن بایاس محاسبه می‌کنیم:
            وزن‌ها ($W$) = $\begin{bmatrix}3 & 2\end{bmatrix}$
            ورودی ($p$) = $\begin{bmatrix}-5 \\ 7\end{bmatrix}$
        </p>
        $$
        n_{initial} = Wp = \begin{bmatrix}3 & 2\end{bmatrix} \begin{bmatrix}-5 \\ 7\end{bmatrix} = (3 \times -5) + (2 \times 7) = -15 + 14 = -1
        $$
        <p>
            حالا، ورودی خالص کلی نرون ($n$) با در نظر گرفتن بایاس ($b$) برابر خواهد بود با:
        </p>
        $$
        n = n_{initial} + b = -1 + b
        $$
        <p>
            هدف این است که خروجی نرون ($a$) برابر $0.5$ باشد.
        </p>
        <ol type="i">
            <li>
                **آیا تابع انتقالی از جدول ۲.۱ وجود دارد که اگر بایاس صفر باشد، این کار را انجام دهد؟**
                <p>اگر بایاس ($b$) صفر باشد، آنگاه $n = -1$. ما می‌خواهیم $f(-1) = 0.5$.</p>
                <ul>
                    <li><b>تابع خطی (purelin):</b> $f(-1) = -1 \ne 0.5$.</li>
                    <li><b>تابع Log-sigmoid (logsig):</b> $logsig(-1) = \frac{1}{1 + e^{-(-1)}} = \frac{1}{1 + e} \approx \frac{1}{1 + 2.718} \approx 0.2689 \ne 0.5$.</li>
                    <li><b>تابع Tan-sigmoid (tansig):</b> $tansig(-1) = \frac{2}{1 + e^{-2(-1)}} - 1 = \frac{2}{1 + e^2} - 1 \approx \frac{2}{1 + 7.389} - 1 \approx 0.2384 - 1 = -0.7616 \ne 0.5$.</li>
                    <li><b>تابع Hard Limit (hardlim):</b> $hardlim(-1) = 0 \ne 0.5$.</li>
                    <li><b>تابع Symmetric Hard Limit (hardlims):</b> $hardlims(-1) = -1 \ne 0.5$.</li>
                </ul>
                <p><b>نتیجه:</b> خیر، هیچ یک از توابع انتقال استاندارد (که معمولاً در "جدول ۲.۱" کتاب‌های درسی یافت می‌شوند) نمی‌توانند برای ورودی خالص $-1$ خروجی $0.5$ را تولید کنند.</p>
            </li>
            <li>
                **آیا بایاسی وجود دارد که اگر از تابع انتقال خطی استفاده شود، این کار را انجام دهد؟ اگر بله، چیست؟**
                <p>اگر تابع انتقال خطی ($f(x) = x$) باشد، آنگاه خروجی ($a$) برابر با ورودی خالص ($n$) است. ما می‌خواهیم $a = 0.5$، پس $n = 0.5$.</p>
                <p>می‌دانیم $n = -1 + b$. پس:</p>
                $$
                -1 + b = 0.5 \implies b = 0.5 + 1 \implies b = 1.5
                $$
                <p><b>نتیجه:</b> بله، بایاس $b = 1.5$ می‌تواند این کار را انجام دهد.</p>
            </li>
            <li>
                **آیا بایاسی وجود دارد که اگر از تابع انتقال log-sigmoid استفاده شود، این کار را انجام دهد؟ اگر بله، چیست؟**
                <p>اگر تابع انتقال log-sigmoid ($f(x) = \frac{1}{1 + e^{-x}}$) باشد، ما می‌خواهیم $a = 0.5$.</p>
                $$
                0.5 = \frac{1}{1 + e^{-n}}
                $$
                <p>با معکوس کردن معادله:</p>
                $$
                \frac{1}{0.5} = 1 + e^{-n} \implies 2 = 1 + e^{-n} \implies 1 = e^{-n}
                $$
                <p>برای اینکه $e^{-n} = 1$ باشد، باید نما (توان) آن یعنی $-n$ برابر با $0$ باشد (زیرا $e^0 = 1$).</p>
                $$
                -n = 0 \implies n = 0
                $$
                <p>حالا که مقدار $n$ را داریم، می‌توانیم بایاس ($b$) را پیدا کنیم:</p>
                $$
                n = -1 + b \implies 0 = -1 + b \implies b = 1
                $$
                <p><b>نتیجه:</b> بله، بایاس $b = 1$ می‌تواند این کار را انجام دهد.</p>
            </li>
        </ol>

    </div>
</body>
</html>
